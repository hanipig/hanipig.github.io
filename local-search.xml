<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TCP</title>
    <link href="/2021/11/20/%E7%BB%8F%E5%85%B8/"/>
    <url>/2021/11/20/%E7%BB%8F%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="从输入-URL-到页面加载发生了什么？"><a href="#从输入-URL-到页面加载发生了什么？" class="headerlink" title="从输入 URL 到页面加载发生了什么？"></a>从输入 URL 到页面加载发生了什么？</h2><ul><li>1.浏览器的地址栏输入 URL 并按下回车</li><li>2.浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期</li><li>3.DNS 解析 URL 对应的 ip</li><li>4.根据 ip 建立 TCP 连接（三次握手）</li><li>5.HTTP 发起请求</li><li>6.服务器处理请求，浏览器接收 HTTP 响应</li><li>7.渲染页面，构建 DOM 树</li><li>8.关闭 TCP 连接</li></ul><blockquote><p>可能会牵扯到 DNS 缓存、浏览器缓存、TCP 三次握手、TCP 四次握手、浏览器渲染原理、HTPP 状态码</p></blockquote><h3 id="DNS-缓存（浏览器、操作系统、Local-DNS、根域名服务器）"><a href="#DNS-缓存（浏览器、操作系统、Local-DNS、根域名服务器）" class="headerlink" title="DNS 缓存（浏览器、操作系统、Local DNS、根域名服务器）"></a>DNS 缓存（浏览器、操作系统、Local DNS、根域名服务器）</h3><blockquote><ol><li>首先搜索浏览器自身的 DNS 缓存，如果存在，则域名解析到此完成</li><li>如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的 hosts 文件查看是否存在对应的映射关系，如果存在。。</li><li>如果本地 hosts 文件不存在映射关系，则查找本地 DNS 服务器，如果存在。。</li><li>如果本地 DNS 服务器还没找到的话，他就会向根服务器发出请求，进行递归查询</li></ol></blockquote><h3 id="TCP-三次握手、四次挥手"><a href="#TCP-三次握手、四次挥手" class="headerlink" title="TCP 三次握手、四次挥手"></a>TCP 三次握手、四次挥手</h3><ul><li><ol><li>TCP/IP 协议是传输层的一个面向连接的安全可靠的一个传输协议，三次握手的机制是为了保证能建立一个安全可靠的连接，那么第一次握手是由客户端发起，客户端会向服务端发送一个报文，在报文里面：SYN 标志位置为 1，表示发起新的连接。当服务端收到这个报文之后就知道客户端要和我建立一个新的连接，于是服务端就向客户端发送一个确认消息包，在这个消息包里面：ack 标志位置为 1，表示确认客户端发起的第一次连接请求。以上两次握手之后，对于客户端而言：已经明确了我既能给服务端成功发消息，也能成功收到服务端的响应。但是对于服务端而言：两次握手是不够的，因为到目前为止，服务端只知道一件事，客户端发给我的消息我能收到，但是我响应给客户端的消息，客户端能不能收到我是不知道的。所以，还需要进行第三次握手，第三次握手就是当客户端收到服务端发送的确认响应报文之后，还要继续去给服务端进行回应，也是一个 ack 标志位置 1 的确认消息。通过以上三次连接，不管是客户端还是服务端，都知道我既能给对方发送消息，也能收到对方的响应。那么，这个连接就被安全的建了。</li></ol></li><li><ol start="2"><li>四次握手机制也是由客户端去发起，客户端会发送一个报文，在报文里面 FIN 位标志位置一，当服务端收到这个报文之后，我就知道了客户端想要和我断开连接，但是此时服务端不一定能做好准备，因为当客户端发起断开连接的这个消息的时候，对于服务端而言，他和还有可能有未发送完的消息，他还要继续发送，所以呢，此时对于服务端而言，我只能进行一个消息确认，就是我先告诉服务端，我知道你要给我断开连接了，但是我这里边还可能没有做好准备，你需要等我一下，等会儿我会告诉你，于是呢，发完这个消息确认包之后，可能稍过片刻它就会继续发送一个断开连接的一个报文啊，也是一个 FIN 位置 1 的报文也是由服务端发给客户端的啊，这个报文表示服务端已经做好了断开连接的准备，那么当这个报文发给客户端的时候，客户端同样要给服务端继续发送一个消息确认的报文一共有四次，那么，通过这四次的相互沟通和连接，我就知道了，不管是服务端还是客户端都已经做好了断开连接的准备，于是连接就可以被断开啊，这是我对三次握手和四次挥手的一个理解。</li></ol></li><li><ol start="3"><li>当客户端进入 TIME-WAIT 状态的时候(也就是第四次挥手的时候)，必须经过时间计数器设置的时间 2MSL(最长报文段寿命)后，才能进入关闭状态，这时为什么呢？？？</li></ol><ul><li><ol><li>为了保证客户端发送的最后一个 ACK 报文段能够到达服务器。因为这个 ACK 有可能丢失，从而导致处在 LAST-ACK 状态的服务器收不到对 FIN-ACK 的确认报文。服务器会超时重传这个 FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待 2MSL，而是在发送完 ACK 之后直接释放关闭，一但这个 ACK 丢失的话，服务器就无法正常的进入关闭连接状态。</li></ol></li><li><ol start="2"><li>他还可以防止已失效的报文段。客户端在发送最后一个 ACK 之后，再经过 2MSL，就可以使本链接持续时间内所产生的所有报文段都从网络中消失。从保证在关闭连接后不会有还在网络中滞留的报文段去骚扰服务器。</li></ol></li></ul></li></ul><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><blockquote><ol><li>什么是浏览器缓存？浏览器缓存其实就是浏览器保存通过 HTTP 获取的所有资源,是浏览器将网络资源存储在本地的一种行为。</li></ol></blockquote><blockquote><ol start="2"><li>缓存的资源存储在哪？有啥区别？memory cache、disk cache</li></ol></blockquote><blockquote><ol start="3"><li>浏览器缓存的分类？</li></ol><ul><li><ol><li>强缓存：Expires、Cache-Control</li></ol></li><li><ol start="2"><li>协商缓存：Last-Modify/If-Modify-Since、Etag/If-None-Match</li></ol></li></ul><ol start="4"><li>浏览器缓存的优点？</li></ol><ul><li><ol><li>减少了冗余的数据传输</li></ol></li><li><ol start="2"><li>减少了服务器的负担，大大提升了网站的性能</li></ol></li><li><ol start="3"><li>加快了客户端加载网页的速度</li></ol></li></ul></blockquote><h3 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h3><h3 id="常见的-HTTP-状态码"><a href="#常见的-HTTP-状态码" class="headerlink" title="常见的 HTTP 状态码"></a>常见的 HTTP 状态码</h3>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经典</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高频</title>
    <link href="/2021/11/20/%E9%AB%98%E9%A2%91/"/>
    <url>/2021/11/20/%E9%AB%98%E9%A2%91/</url>
    
    <content type="html"><![CDATA[<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ul><li><p>讲讲 js 数据类型？基本和引用的区别？symbol 和 bigint 讲一讲应用场景？</p><blockquote><ol><li>分基本数据类型、引用类型</li><li>基本：string，number，boolean，undefined，null，symbol，bigint；引用：object</li><li>基本数据类型按值访问，保存在栈中，存储大小固定；引用类型按引用访问，存储在内存中，大小不定</li><li>Symbol 指的是独一无二的值。每个通过 Symbol() 生成的值都是唯一的，通常用来生成对象属性名，为避免重复；BigInt 数据类型提供了一种方法来表示大于 2^53 的整数。BigInt 可以表示任意大的整数。解决超出 2^53 数字范围精度丢失问题</li></ol></blockquote></li><li><p>判断数据类型的方法？instanceof 原理?判断空对象？ typof null？typeof NaN？</p><blockquote><ol><li>typeof、instanceof、isArray、Object.prototype.toString()</li><li>typeof 可能的值：string、number、boolean、undefined、sysbol、bigint、function、object；typeof 能检测出除 null 的其他基本类型，不能明确区分是哪种引用类型，可通过 instancof 检测是否是某种引用类型或者 使用 Object.prototype.toString</li><li>判断对象是否为空：（1）JSON.stringify(obj) === “{}”（2）for in 判断（3）ES6 Object.keys()（4）Object.getOwnPropertyNames()方法</li></ol></blockquote></li><li><p>var/let/const 区别？暂时性死区？块级作用域？const a = {}; a.x = 1 能不能修改？</p><blockquote><p>var 声明提升，可重复声明；let、const 添加了块级作用域，约束了声明提升，在声明之前不能使用，不然会报错（暂时性死区），不能重复声明；const 声明的时候就要赋值，而且不能重新赋值（但是引用类型可修改属性）</p></blockquote></li><li><p>说说你对函数式编程的理解？函数柯里化的理解？平时的使用场景？</p><blockquote><ol><li>简单说，”函数式编程”是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论.它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是”第一等公民”、只用”表达式”</li><li>在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可用于在不侵入函数的前提下，为函数 预置通用参数，供多次重复调用。</li></ol></blockquote></li><li><p>防抖、节流的含义，使用场景？手写一下？</p><blockquote><ol><li>所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</li><li>所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。</li></ol></blockquote></li><li><p>call、apply、bind 区别？bind 实现？bind 之后还能修改 this 指向吗？为什么？</p><blockquote><ol><li>相同点：三者都可修改函数运行时的 this 指向</li><li>不同点：bind 返回修改 this 后的函数，并不会立即执行函数；apply、call 修改完 this 立即执行；apply 于 call 区别在于传参不同，前者传入数组，后者逐个参数传入</li><li>bind 之后不能修改 this 的指向</li></ol></blockquote></li><li><p>闭包概念，最主要的还是问闭包的场景？</p></li><li><p>用 es5 实现 es6 类的继承？各种继承</p></li><li><p>深拷贝与浅拷贝？常用方法？手写一个深拷贝函数？</p></li><li><p>说说你知道的 JavaScript 设计模式？观察者和发布订阅的区别？手写一个发布订阅？</p></li><li><p>说说对你对 JavaScript 异步编程的理解？</p></li><li><p>ES Module 与 CommonJS 模块的差异？两者互相加载的方式？一般会扯到 AMD</p></li><li><p>Promise.all、race、allSettled 概念、手写？很多手写题都会用到，比如用 promise 实现请求并发个数限制？</p></li><li><p>对象创建？</p><ul><li><ol><li>对象字面量模式：</li></ol></li><li><ol start="2"><li>工厂模式</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPerson</span> (<span class="hljs-params">name, age</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>  o.name = name;<br>  o.age = age;<br>  o.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  &#125;<br>  <span class="hljs-keyword">return</span> o;<br>&#125;<br><span class="hljs-keyword">let</span> person1 = createPerson(<span class="hljs-string">&quot;sup h&quot;</span>, <span class="hljs-number">24</span>);<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>可解决多个类似对象的问题，但没有解决对象标识问题（instanceof）；</p></blockquote><ul><li><ol start="3"><li> 构造函数模式</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.age = age;<br>  <span class="hljs-built_in">this</span>.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;sup h&quot;</span>, <span class="hljs-number">24</span>);<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>可确保实例被标识为特定类型，但其定义的方法会在每个实例上都创建一遍；即使把函数定义转移到构造函数外部可解决重复创建的问题，但是会污染全局函数。</p></blockquote><ul><li><ol start="4"><li>原型模式</li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br><br>Person.prototype.name = <span class="hljs-string">&quot;sup h&quot;</span>;<br>Person.prototype.age = <span class="hljs-number">24</span>;<br>Person.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> Person();<br></code></pre></td></tr></table></figure><blockquote><p>好处是，在它上面定义的属性和方法可被对象实例共享；缺点是，（1）弱化了构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值（2）共享特性（针对引用类型）</p></blockquote></li><li><p>对象继承？</p><ul><li><ol><li>原型链</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">//父类</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.property = <span class="hljs-literal">true</span>;<br>&#125;<br><br>SuperType.prototype.getSuperValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.property;<br>&#125;<br><br><span class="hljs-comment">//子类</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.subProperty = <span class="hljs-literal">false</span>;<br>&#125;<br><br>SubType.prototype = <span class="hljs-keyword">new</span> SuperType();<br><br>SubType.prototype.getSubValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.subProperty;<br>&#125;<br><br><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> SubType();<br><span class="hljs-built_in">console</span>.log(instance.getSuperValue());<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><blockquote><p>缺点（1）引用类型值共享（2）子类型在实例化时不能向父类型的构造函数传递参数</p></blockquote></li><li><ol start="2"><li>盗用构造函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span> (<span class="hljs-params"></span>) </span>&#123;<br>  SuperType.call(<span class="hljs-built_in">this</span>);<span class="hljs-comment">//借用父类构造器</span><br>&#125;<br><br><span class="hljs-keyword">let</span> instance1 = <span class="hljs-keyword">new</span> SubType();<br>instance1.colors.push(<span class="hljs-string">&quot;yellow&quot;</span>);<br><span class="hljs-built_in">console</span>.log(instance1.colors);<span class="hljs-comment">//&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;</span><br><br><span class="hljs-keyword">let</span> instance2 = <span class="hljs-keyword">new</span> SubType();<br><span class="hljs-built_in">console</span>.log(instance2.colors);<span class="hljs-comment">//&quot;red&quot;, &quot;blue&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>优点（1）相对比原型链继承，盗用构造函数的一个优点是可以向父类构造函数传递参数（2）父类中的引用类型值不会共享；缺点（1）必须在函数中定义方法，因此函数不能重用，子类也不能访问父类原型上定义的方法。</p></blockquote></li><li><ol start="3"><li>组合继承</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span> (<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&quot;res&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>];<br>&#125;<br><br>SuperType.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span> (<span class="hljs-params">name, age</span>) </span>&#123;<br>  SuperType.call(<span class="hljs-built_in">this</span>, name);<span class="hljs-comment">//第一次调用</span><br>  <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><br>SubType.prototype = <span class="hljs-keyword">new</span> SuperType();<span class="hljs-comment">//第二次调用</span><br><br>SubType.prototype.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.age);<br>&#125;<br><br><span class="hljs-keyword">let</span> instance1 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">&quot;suph&quot;</span>, <span class="hljs-number">24</span>);<br><span class="hljs-keyword">let</span> instance2 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">&quot;hanipig&quot;</span>, <span class="hljs-number">25</span>);<br><br>instance1.colors.push(<span class="hljs-string">&quot;yellow&quot;</span>);<br><br><span class="hljs-built_in">console</span>.log(instance1.colors);<br><span class="hljs-built_in">console</span>.log(instance2.colors);<br></code></pre></td></tr></table></figure><blockquote><p>使用的最多，但并不完美，存在效率问题 =&gt; 父类构造函数被调用了两次</p></blockquote></li><li><ol start="4"><li>原型式继承（Object.create()的实现）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">//obj为需要继承的对象</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Object</span> (<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> func = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br>  func.prototype = obj;<span class="hljs-comment">//浅复制，实例都会共享此对象</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> func();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><ol start="5"><li>寄生式继承</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Object2</span> (<span class="hljs-params">obj</span>)) </span>&#123;<br>  <span class="hljs-keyword">let</span> newObj = object(obj);<span class="hljs-comment">//object为 任何可返回对象的方法即可</span><br>  newObj.newProperty = <span class="hljs-string">&quot;anything&quot;</span>;<span class="hljs-comment">//在旧obj基础上添加任意属性</span><br>  <span class="hljs-keyword">return</span> newObj;<span class="hljs-comment">//即实现了继承旧对象又追加了新增的属性</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><ol start="6"><li>寄生组合式继承（在组合继承的基础上少调用了一次父类构造函数）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritPrototype</span> (<span class="hljs-params">child, parent</span>)) </span>&#123;<br>  <span class="hljs-keyword">let</span> prototype = object(parent.prototype);<span class="hljs-comment">//object为 任何可返回对象的方法即可</span><br>  prototype.constructor = child;<span class="hljs-comment">//修改prototype的construstor属性</span><br>  child.prototype = prototype;<span class="hljs-comment">//直接重写子类的原型对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span> (<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&quot;res&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>];<br>&#125;<br><br>SuperType.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span> (<span class="hljs-params">name, age</span>) </span>&#123;<br>  SuperType.call(<span class="hljs-built_in">this</span>, name);<span class="hljs-comment">//第一次调用</span><br>  <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><br>inheritPrototype(SubType, SuperType);<br><br>SubType.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.age);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Http-amp-amp-浏览器"><a href="#Http-amp-amp-浏览器" class="headerlink" title="Http &amp;&amp; 浏览器"></a>Http &amp;&amp; 浏览器</h2><ul><li>浏览器缓存？http 缓存？ 主要要讲一讲强缓存、协商缓存、preload、prefetch、Service Worker 等，304 的含义？协商缓存 e-tag 是怎么生成的？Last-Modified 是基于什么生成的？两者对比一下？优先级哪个高？</li><li>什么是跨域？什么情况下会跨域？浏览器根据什么字段判断是否允许跨域？跨域的解决方案有哪些？options 请求了解过吗？说说 CORS 中的简单请求和复杂请求？form 表单提交会跨域吗？</li><li>讲一讲浏览器事件循环 Event Loop？node 事件循环描述一下？</li><li>http2 有哪些新特性？http2 还有哪些缺陷？http3 的一些了解？</li><li>从输入 URL 到页面加载完成的过程，一般要很详细的描述：包括 DNS 查询，缓存查询，3 次握手，4 次挥手，浏览器渲染进程等，面试官会从里面再挑几个问题深入问，比如为什么是 3 次握手 4 次挥手？渲染进程中的 GUI 渲染线程、JS 引擎线程、事件触发线程等等？可能会问到进程线程的区别？浏览器为什么是多进程？js 为什么是单线程？怎么支持多线程？等等</li><li>https 加密原理？主要是讲对称加密和非对此加密结合使用的一个过程。什么是中间人攻击？和 http 区别？</li></ul><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><ul><li>生命周期？那个生命周期可以获取到真实 DOM？修改 data 里面的数据，会触发什么生命周期？</li><li>组件 data 为什么是一个函数？</li><li>vue 组件通信？一般说了 vuex，就会问 vuex 用法？action 和 mutations 区别？实现原理等？</li><li>vue 导航守卫，分全局和组件的，一般用于权限控制，这个就可能扯到项目中的一些鉴权问题。</li><li>$nextTick 作用？实现原理？微任务向宏任务的降级处理，经常被问到说出几种宏任务，微任务。</li><li>vue 响应式原理？基本都会问</li><li>vue scoped 属性作用？实现原理？</li><li>vue router 有几种模式？实现方式？</li><li>key 的作用？没有 key 的情况，vue 会怎么做？会引出 diff 的问题</li><li>vue diff 过程，和 react diff 区别？</li><li>vue 2.x defineProperty 缺陷？业务代码里面怎么处理？$set 原理？vue 是怎么重写数组方法的？考察你是不是真的看过源码</li><li>vue 3.0 proxy 优缺点？怎么处理 vue3 不支持 IE？</li><li>computed 和 watch 的区别和运用的场景？除了基本的，看你能不能说出三种 watcher 的区别</li></ul><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><ul><li><p>webpack 构建流程？打包原理？</p><blockquote><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p></blockquote><ul><li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li><li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译</li><li>确定入口：根据配置中的 entry 找出所有的入口文件</li><li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li>完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ul><blockquote><p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。简单说</p></blockquote><ul><li>初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler</li><li>编译：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li><li>输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中</li></ul></li><li><p>项目中做的一些优化？</p></li><li><p>loader 和 plugin 的区别？有没有写过？常用哪些 loader 和 plugin</p></li><li><p>webpack 热跟新原理？</p></li><li><p>tree-shaking？对于 CommonJS，tree shaking 怎么办？</p></li><li><p>webpack loader 的执行顺序？从左到右？从上到下？</p></li></ul><h2 id="tcp-三次握手四次挥手"><a href="#tcp-三次握手四次挥手" class="headerlink" title="tcp 三次握手四次挥手"></a>tcp 三次握手四次挥手</h2><ul><li><ol><li>TCP/IP 协议是传输层的一个面向连接的安全可靠的一个传输协议，三次握手的机制是为了保证能建立一个安全可靠的连接，那么第一次握手是由客户端发起，客户端会向服务端发送一个报文，在报文里面：SYN 标志位置为 1，表示发起新的连接。当服务端收到这个报文之后就知道客户端要和我建立一个新的连接，于是服务端就向客户端发送一个确认消息包，在这个消息包里面：ack 标志位置为 1，表示确认客户端发起的第一次连接请求。以上两次握手之后，对于客户端而言：已经明确了我既能给服务端成功发消息，也能成功收到服务端的响应。但是对于服务端而言：两次握手是不够的，因为到目前为止，服务端只知道一件事，客户端发给我的消息我能收到，但是我响应给客户端的消息，客户端能不能收到我是不知道的。所以，还需要进行第三次握手，第三次握手就是当客户端收到服务端发送的确认响应报文之后，还要继续去给服务端进行回应，也是一个 ack 标志位置 1 的确认消息。通过以上三次连接，不管是客户端还是服务端，都知道我既能给对方发送消息，也能收到对方的响应。那么，这个连接就被安全的建了。</li></ol></li><li><ol start="2"><li>四次握手机制也是由客户端去发起，客户端会发送一个报文，在报文里面 FIN 位标志位置一，当服务端收到这个报文之后，我就知道了客户端想要和我断开连接，但是此时服务端不一定能做好准备，因为当客户端发起断开连接的这个消息的时候，对于服务端而言，他和还有可能有未发送完的消息，他还要继续发送，所以呢，此时对于服务端而言，我只能进行一个消息确认，就是我先告诉服务端，我知道你要给我断开连接了，但是我这里边还可能没有做好准备，你需要等我一下，等会儿我会告诉你，于是呢，发完这个消息确认包之后，可能稍过片刻它就会继续发送一个断开连接的一个报文啊，也是一个 FIN 位置 1 的报文也是由服务端发给客户端的啊，这个报文表示服务端已经做好了断开连接的准备，那么当这个报文发给客户端的时候，客户端同样要给服务端继续发送一个消息确认的报文一共有四次，那么，通过这四次的相互沟通和连接，我就知道了，不管是服务端还是客户端都已经做好了断开连接的准备，于是连接就可以被断开啊，这是我对三次握手和四次挥手的一个理解。</li></ol></li><li><ol start="3"><li>当客户端进入 TIME-WAIT 状态的时候(也就是第四次挥手的时候)，必须经过时间计数器设置的时间 2MSL(最长报文段寿命)后，才能进入关闭状态，这时为什么呢？？？</li></ol><ul><li><ol><li>为了保证客户端发送的最后一个 ACK 报文段能够到达服务器。因为这个 ACK 有可能丢失，从而导致处在 LAST-ACK 状态的服务器收不到对 FIN-ACK 的确认报文。服务器会超时重传这个 FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待 2MSL，而是在发送完 ACK 之后直接释放关闭，一但这个 ACK 丢失的话，服务器就无法正常的进入关闭连接状态。</li></ol></li><li><ol start="2"><li>他还可以防止已失效的报文段。客户端在发送最后一个 ACK 之后，再经过 2MSL，就可以使本链接持续时间内所产生的所有报文段都从网络中消失。从保证在关闭连接后不会有还在网络中滞留的报文段去骚扰服务器。</li></ol></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高频</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue总结</title>
    <link href="/2021/11/20/Vue/"/>
    <url>/2021/11/20/Vue/</url>
    
    <content type="html"><![CDATA[<h3 id="vue-cli创建项目"><a href="#vue-cli创建项目" class="headerlink" title="vue-cli创建项目"></a>vue-cli创建项目</h3><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li>插值表达式</li><li>v-html：有xss风险，会覆盖子组件</li><li>computed 有缓存，data不变则不会重新计算</li><li>watch 深度监听、监听引用类型，拿不到oldVal</li><li>class和style</li><li>条件渲染</li><li>v-if v-show的区别，使用场景</li><li>v-for、遍历对象、key 的重要性、v-for 和 v-if不建议同时使用</li><li>事件、event参数，自定义参数、事件修饰符，按键修饰符、事件被绑定到哪里（event.target,event.currentTarget）？<blockquote><p>1.event是原生的</p><p>2.事件被挂载到当前元素</p></blockquote></li><li>表单、v-model</li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul><li>props 和 $emit</li><li>组件间通讯-自定义事件<blockquote><p>父子间<br>任意层级间 自定义事件（$on、$off、$emit）</p></blockquote></li><li>组件生命周期<blockquote><p>单个组件（挂载、更新、销毁）</p><p>父子组件：</p><ol><li>父组件beforeCreate –&gt; 父组件created –&gt; 父组件beforeMount  –&gt; 子组件beforeCreate –&gt; 子组件created –&gt; 子组件beforeMount  –&gt;  子组件 mounted  –&gt; 父组件mounted </li><li>父组件beforeUpdate =&gt; 子组件beforeUpdate =&gt;子组件updated =&gt; 父组件updated</li><li>父组件beforeDestroy =&gt; 子组件beforeDestroy =&gt; 子组件destroyed =&gt; 父组件destroyed</li></ol></blockquote></li></ul><h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><ul><li>自定义v-model</li><li>$nextTick<blockquote><p>1.Vue是异步渲染的</p><p>2.data改变后，Dom不会立刻渲染，会将多次修改data修改做整合</p><p>3.$nextTick会在DOM渲染之后被触发，以获取最新DOM节点</p></blockquote></li><li>slot<ul><li>基本使用</li><li>作用于插槽</li><li>具名插槽</li></ul></li><li>动态组件 conponent is</li><li>异步组件<ul><li>import()函数</li><li>按需加载，异步加载大组件</li></ul></li><li>keep-alive<ul><li>缓存组件</li><li>频繁切换，不需要重复渲染 </li></ul></li><li>mixin<ul><li>多个组件有相同的逻辑，抽离出来</li><li> mixin并不是完美的解决方案，会有一些问题</li><li> Vue3提出Composition API旨在解决这些问题</li></ul></li></ul><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><ul><li><p>state</p></li><li><p>getters</p></li><li><p>actions</p></li><li><p>mutations（原子性操作）</p></li><li><p>dispatch</p></li><li><p>commit</p></li><li><p>mapState</p></li><li><p>mapGetters</p></li><li><p>mapActions</p></li><li><p>mapMutations</p></li></ul><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><ul><li>路由模式（hash、H5 history）</li><li>路由配置（动态路由、懒加载）</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 原理</title>
    <link href="/2021/11/20/Vue%E5%8E%9F%E7%90%86/"/>
    <url>/2021/11/20/Vue%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="组件化-和-MVVM"><a href="#组件化-和-MVVM" class="headerlink" title="组件化 和 MVVM"></a>组件化 和 MVVM</h3><blockquote><p>1.很早之前就有组件化这个概念，jsp php ，但都是静态渲染，需要通过操作 dom 实现更新 2.vue 较传统的组件化采用数据驱动视图、mvvm</p></blockquote><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><ul><li>核心 API - Object.defineProperty</li><li>响应式代码实现<ul><li>监听对象、监听数组</li><li>复杂对象、深度监听</li><li>几个缺点<blockquote><ol><li>深度监听，需要地柜到底，一次性计算量大</li><li>无法监听新增/删除属性（Vue.set、Vue.delete）</li><li>无法原生监听数组，需要特殊处理</li></ol></blockquote></li></ul></li><li>Object.defineProperty 缺点</li><li>Vue3.0 Proxy，兼容性问题</li></ul><h3 id="vdom"><a href="#vdom" class="headerlink" title="vdom"></a>vdom</h3><blockquote><ol><li>DOM 操作非常耗费性能</li><li>以前用 jQuery，可以自行控制 DOM 操作的时机，手动调整</li><li>Vue 和 React 是数据驱动视图，如何有效控制 DOM 操作？</li></ol></blockquote><blockquote><p>解决方案：</p><ol><li>有了一定的复杂度， 想减少计算次数比较难；</li><li>能不能把计算，更多的转移为 JS 计算？因为 JS 执行速度很快；</li><li>vdom - 用 JS 模拟 DOM 结构，计算出最小的变更，操作 DOM；</li></ol></blockquote><h3 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h3><blockquote><ol><li>diff 算法是 vdom 中最核心、最关键的部分</li><li>diff 算法能在日常使用 vue react 中体现出来（key）</li><li>diff 即对比，是一个广泛的概念</li></ol></blockquote><h4 id="diff-优化实践复杂度到-O-n"><a href="#diff-优化实践复杂度到-O-n" class="headerlink" title="diff 优化实践复杂度到 O(n)"></a>diff 优化实践复杂度到 O(n)</h4><blockquote><ol><li>只比较同一级别，不跨级比较</li><li>tag 不相同，则直接删除重建，不再深度比较</li><li>tag 和 key，两者都相同，则认为是相同节点，不再深度比较</li></ol></blockquote><h4 id="涉及到的函数"><a href="#涉及到的函数" class="headerlink" title="涉及到的函数"></a>涉及到的函数</h4><blockquote><ol><li>h 函数返回 vnode 结构{sel, data, children, text, ele, key}</li><li>patch 函数(isSameVnode 否：销毁重建) =&gt; pathVonde（1.判断 text 是否不相等，销毁旧 vnode 插入新 vnode 2.1 新旧 child 都存在走 undateChildren 2.2 新 childe 存在，旧 child 不存在，把旧 vnode.text 置空并添加新 child 2.3 旧 child 存在，新 child 不存在，移除旧 vnode 2.4 旧 text 都存在，新 text 不存在，直接置空旧 text） =&gt; updateChildren（1.头头、头尾、尾头、尾尾对比，相同就 继续 patchVnode 2. 在旧 child 中查找当前 startIndex 的 key 是否存在，存在就进一步比较 tag，相同就继续 patchVnode，不相同就插入新 child）</li></ol></blockquote><h3 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h3><blockquote><ol><li>前置知识：JS 的 with 语法</li><li>vue-template-complier （webpack 环境下是 vue-loader 编译）将模板编译成 render 函数</li><li>执行 render 函数生成 vnode</li></ol></blockquote><h3 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h3><ul><li><p>初次渲染过程</p><blockquote><ol><li>解析模板为 render 函数（或在开发环境已完成，vue-loader）</li><li>触发响应式，监听 date 属性 getter setter</li><li>执行 render 函数，生成 vnode，patch(ele,vnode)</li></ol></blockquote></li><li><p>更新过程</p><blockquote><ol><li>修改 data，触发 setter（此前在 getter 中已被监听）</li><li>重新执行 render 函数，生成 newVnode</li><li>patch(vnode, newVnode)</li></ol></blockquote></li><li><p>异步渲染</p><blockquote><ol><li>$nextTick</li><li>汇总 data 的修改，一次性更新视图</li><li>减少 DOM 操作次数，提高性能</li></ol></blockquote></li></ul><h3 id="前端路由原理"><a href="#前端路由原理" class="headerlink" title="前端路由原理"></a>前端路由原理</h3><ul><li>hash</li><li>H5 history</li></ul><h4 id="hash-的特点"><a href="#hash-的特点" class="headerlink" title="hash 的特点"></a>hash 的特点</h4><blockquote><ol><li>hash 变化会触发网页跳转，即浏览器的前进、后退</li><li>hash 变化不会刷新页面，SPA 必需的特点</li><li>hash 永远不会提交到 server 端</li></ol></blockquote><h5 id="window-onhashchange（怎么触发）"><a href="#window-onhashchange（怎么触发）" class="headerlink" title="window.onhashchange（怎么触发）"></a>window.onhashchange（怎么触发）</h5><blockquote><ol><li>JS 修改 hash</li><li>手动修改 url</li><li>浏览器前进后退</li></ol></blockquote><h4 id="H5-history（需要后台配合，始终返回-index-html）"><a href="#H5-history（需要后台配合，始终返回-index-html）" class="headerlink" title="H5 history（需要后台配合，始终返回 index.html）"></a>H5 history（需要后台配合，始终返回 index.html）</h4><blockquote><ol><li>用 url 规范的路由，但跳转时不刷新页面</li><li>history.pushState</li><li>window.onpopstate</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack</title>
    <link href="/2021/11/20/Webpack/"/>
    <url>/2021/11/20/Webpack/</url>
    
    <content type="html"><![CDATA[<ul><li>多入口打包</li><li>抽离 css 文件：mini-css-extract-plugin</li><li>抽离公共代码、第三方代码：添加 optimization.splitChunks（initial：入口 chunk，对异步导入的文件不处理；async：异步 chunk，只对异步导入的文件处理；all：全部 chunk）、optimization.cacheGroups.vendor（第三方模块）、optimization。cacheGroups.common（公共模块）</li><li>异步加载、处理 jxs、vue（vue-loader）</li><li>module、chunk、bundle 的区别<blockquote><p>module：各个源码文件，webpack 中一切皆模块</p><p>chunk：多个模块合成的，如 entry、import()、splitChunk</p><p>bundle：最终的输出文件</p></blockquote></li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul><li><p>开发环境</p><ul><li>优化打包构建速度<ul><li>HMR(hot module replacement):热模块替换/模块热替换<blockquote><p>作用：一个模块发生变化，只会重新打包这一个模块（而不是打包所有模块），极大提升构建速度</p><p>样式文件：可以使用 HMR 功能：因为 style-loader 内部实现了</p><p>js 文件：默认不能使用 HMR 功能</p><p>html 文件：默认不能使用 HMR 功能，同时会导致 html 文件不能热更新了(解决：修改 entry 成数组形式，并把 index.html 文件也加入)</p><p>html 文件不用 HMR,js 文件需要（只能处理非入口文件）</p></blockquote></li></ul></li><li>优化代码调试<ul><li>source-map：一种提供源代码到构建后代码映射技术</li></ul></li></ul></li><li><p>生产环境</p><ul><li><p>优化打包构建速度</p><ul><li>oneOf：只会匹配一个 loader ，不能有两个配置处理同一种类型文件</li><li>缓存：babel 缓存（直接配置 cacheDirectory: true,让第二次打包构建速度更快）、文件资源缓存<blockquote><p>hash：每次构建时会生成一个唯一的 hash 值，缺点:js css 使用同一个 hash 值，如果重新打包，可能会导致 js css 缓存失效</p><p>chunkhash：根据 chunk 生成的 hash,如果打包来源于同一个 chunk，那么 hash 值就一样、缺点：js 和 css 的 hash 值还是一样，因为 css 是在 js 中被引入的，所以同属于一个 chunk</p><p>contenthash：根据文件的内容生成 hash,根据文件的内容生成的 hash,不同文件 hash 值一定不一样（让代码上线运行缓存更好使用）</p></blockquote></li><li>多进程打包 thread-loader</li><li>externals 拒绝指定包被打包进来（比如采用 cdn 引用进来）</li><li>dll 动态连接库：使用 dll 技术对某些库进行单独打包</li></ul></li><li><p>优化代码运行性能</p><ul><li><p>tree shaking（去除无用代码，减少代码体积）</p><blockquote><p>前提条件（1.使用 es6 模块化 2.开启 production 模式 ）</p><p>可搭配 sideEffect 配置防止 css less…等资源被误当做无用代码被过滤</p></blockquote></li><li><p>代码分割（code split）</p><ul><li><p>多入口实现：有一个入口，最终输出就有一个 bundle</p></li><li><p>optimization.splitChunks.chunks：’all’</p><blockquote><p>1.可以将 node_modules 中的代码单独打包成一个 chunk 最终输出</p><p>2.自动分析多入口 chunk 中，有没有公共的文件，如果有会打包成单独的一个 chunk</p></blockquote></li><li><p>通过 js 代码，让某个文件被单独打包成一个 chunk（import 动态导入语法：能将某个文件单独打包）</p><blockquote><p>import(/*webpackChunkName: ‘指定打包后的 chunkname’*/‘./文件’).then((result) =&gt; {</p></blockquote><p>}).then((err) =&gt; {})</p></li></ul></li><li><p>懒加载 lazy loading（当文件需要使用时才加载）、预加载（预加载会在使用之前，提前加载 js 文件）</p><blockquote><p>正常加载可以理解为并行加载（同一时间加载多个文件），预加载：等其他资源加载完毕，浏览器空闲了，再偷偷加载资源（低版本浏览器有兼容性问题，慎用）<br>import(/*webpackChunkName: ‘指定打包后的 chunkname’, webpackPrefetch: true */‘./文件’).then((result) =&gt; {</p></blockquote><p>}).then((err) =&gt; {})</p></li><li><p>PWA 渐进式网络开发应用程序（离线可访问）：workbox –&gt; workbox-webpack-plugin</p></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见手写题</title>
    <link href="/2021/11/20/%E5%B8%B8%E8%A7%81%E6%89%8B%E5%86%99%E9%A2%98/"/>
    <url>/2021/11/20/%E5%B8%B8%E8%A7%81%E6%89%8B%E5%86%99%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="深拷贝函数"><a href="#深拷贝函数" class="headerlink" title="深拷贝函数"></a>深拷贝函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj</span>)</span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(obj) !== <span class="hljs-string">&quot;object&quot;</span> || obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj;<br><br>  <span class="hljs-keyword">let</span> res = <span class="hljs-built_in">Object</span>.prototype.toString.call(obj) === <span class="hljs-string">&quot;[object Array]&quot;</span> ? [] : &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (obj.hasOwnProperty(key)) &#123;<br>      res[key] = deepClone(obj[key]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="instanceof-实现"><a href="#instanceof-实现" class="headerlink" title="instanceof 实现"></a>instanceof 实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceof</span> (<span class="hljs-params">L, R</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> LProto = L.__proto__;<br>  <span class="hljs-keyword">let</span> RPrototype = R.propertype;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (LProto === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> (LProto === RPrototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    LProto = LProto.__proto__;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="防抖、节流"><a href="#防抖、节流" class="headerlink" title="防抖、节流"></a>防抖、节流</h3><blockquote><ol><li>防抖：在规定的时间内多次触发某一事件，会把之前的回调取消，以最后规定时间内一次的触发为准</li></ol><ul><li>this 指向 window 问题</li><li>event 指向 undefined 问题</li><li>怎么实现立即执行</li><li>返回值（只考虑 immediate 为 true 的情况）</li><li>取消</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait, immediate</span>)</span>&#123;<br>  <span class="hljs-keyword">let</span> timer, res;<br><br>  <span class="hljs-keyword">let</span> debounced = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;<span class="hljs-comment">//参数</span><br>    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<span class="hljs-comment">//目标对象</span><br><br>    <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);<span class="hljs-comment">//如果指定时间内再次触发，取消之前的回调</span><br><br>    <span class="hljs-keyword">if</span> (immediate) &#123;<br>      <span class="hljs-keyword">let</span> callNow = !timer;<span class="hljs-comment">//如果之前未执行过，则!timer为true 即立即执行</span><br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        timer = <span class="hljs-literal">null</span>;<span class="hljs-comment">//每次执行完回调把timer设置为null，确保每下一次能够立即执行</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;可以再次触发了&quot;</span>);<br>      &#125;, wait);<br>      <span class="hljs-keyword">if</span> (callNow) &#123;<br>        res = fn.apply(context, args);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        fn.apply(context, args);<br>      &#125;, wait)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<span class="hljs-comment">//只有在immdiate是true时res才可能有值，false时为undefined</span><br>  &#125;<br><br>  <span class="hljs-comment">//取消</span><br>  debounced.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timer);<br>    timer = <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> debounced;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="2"><li>节流：在规定的时间内只会触发执行一次时事件回调</li></ol><ul><li>时间戳实现（立即执行,有头无尾）</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle1</span> (<span class="hljs-params">fn, wait</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> pre = <span class="hljs-number">0</span>;<span class="hljs-comment">//上一次的时间戳</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;<br>    <span class="hljs-keyword">let</span> curr = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><br>    <span class="hljs-keyword">if</span> ((curr - pre) &gt;= wait) &#123;<br>      fn.apply(context, args);<br>      pre = curr;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;可以再次触发了&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>定时器实现（指定时间后执行，无头有尾）</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle2</span> (<span class="hljs-params">fn, wait</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;<br><br>    <span class="hljs-keyword">if</span> (!timer) &#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        timer = <span class="hljs-literal">null</span>;<br>        fn.apply(context, args);<br>      &#125;, wait);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>定时器、时间戳结合实现（有头有尾）</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">//两者结合 有头有尾</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle3</span> (<span class="hljs-params">fn, wait</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timer,<br>    pre = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">let</span> curr = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>    <span class="hljs-keyword">let</span> remaining = wait - (curr - pre);<br>    <span class="hljs-keyword">if</span> (remaining &lt;= <span class="hljs-number">0</span> || remaining &gt; wait) &#123;<span class="hljs-comment">//如果没有剩余的时间了或者改了系统时间</span><br>      <span class="hljs-keyword">if</span> (timer) &#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timer);<br>        timer = <span class="hljs-literal">null</span>;<br>      &#125;<br><br>      pre = curr;<br>      fn.apply(context, args);<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timer) &#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        pre = curr;<br>        timer = <span class="hljs-literal">null</span>;<br>        fn.apply(context, args);<br>      &#125;, remaining);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>定时器、时间戳结合实现（通过 options 参数决定无头有尾、有头无尾）</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">//leading：false 表示禁用第一次执行</span><br><span class="hljs-comment">//trailing: false 表示禁用停止触发的回调</span><br><span class="hljs-comment">//两者不能同时为false</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle4</span> (<span class="hljs-params">fn, wait, options</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timer,<br>    pre = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (!options) options = &#123;&#125;;<br><br>  <span class="hljs-keyword">let</span> throttled =  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">let</span> curr = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><br>    <span class="hljs-keyword">if</span> (!pre &amp;&amp; options.leading === <span class="hljs-literal">false</span>) pre = curr;<span class="hljs-comment">//禁用第一次，采用setTimeout</span><br><br>    <span class="hljs-keyword">let</span> remaining = wait - (curr - pre);<span class="hljs-comment">//禁用第一次时，remaining == wait</span><br><br>    <span class="hljs-keyword">if</span> (remaining &lt;= <span class="hljs-number">0</span> || remaining &gt; wait) &#123;<span class="hljs-comment">//如果没有剩余的时间了或者改了系统时间</span><br>      <span class="hljs-keyword">if</span> (timer) &#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timer);<br>        timer = <span class="hljs-literal">null</span>;<br>      &#125;<br><br>      pre = curr;<br>      fn.apply(context, args);<br><br>      <span class="hljs-keyword">if</span>(!timer) context = args = <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timer &amp;&amp; options.trailing !== <span class="hljs-literal">false</span>) &#123;<span class="hljs-comment">//禁用第一次时</span><br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        pre = options.leading === <span class="hljs-literal">false</span> ? <span class="hljs-number">0</span> : <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();<br>        timer = <span class="hljs-literal">null</span>;<span class="hljs-comment">//??</span><br>        fn.apply(context, args);<br>        <span class="hljs-comment">// if(!timer) context = args = null;//??</span><br>      &#125;, remaining);<br>    &#125;<br>  &#125;<br><br>  throttled.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timer);<br>    pre = <span class="hljs-number">0</span>;<br>    timer = <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> throttled;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="new-实现"><a href="#new-实现" class="headerlink" title="new 实现"></a>new 实现</h3><ul><li><p>创建一个对象</p></li><li><p>把构造函数的原型对象赋值给 obj.__proto__</p></li><li><p>为 obj 绑定 this</p></li><li><p>返回值为基本类型时忽略（即返回创建的这个对象）；返回引用类型时直接忽略创建的这个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">//fn为构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNew</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>;<br>  <span class="hljs-keyword">let</span> Constructor = [].shift.call(<span class="hljs-built_in">arguments</span>);<span class="hljs-comment">//获取构造函数 即fn</span><br>  <span class="hljs-keyword">let</span> prototype = Constructor.prototype;<span class="hljs-comment">//构造函数的原型对象</span><br><br>  obj.__proto__ = prototype;<br><br>  <span class="hljs-comment">//需要考虑构造函数有返回值得情况</span><br>  <span class="hljs-keyword">let</span> res = fn.apply(obj, <span class="hljs-built_in">arguments</span>);<span class="hljs-comment">//调用构造函数，此时arguments已去除构造函数（shift直接修改原数组，返回移除的元素）</span><br><br>  <span class="hljs-comment">//如果返回值是基本类型的则返回obj，否则返回res（此处暂只判断了object，并不全面）</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&quot;object&quot;</span> ? res : obj;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="call、bind、apply"><a href="#call、bind、apply" class="headerlink" title="call、bind、apply"></a>call、bind、apply</h3><ul><li>call：在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">//1.把fn置为obj的方法</span><br><span class="hljs-comment">//2.调用obj.fn</span><br><span class="hljs-comment">//3.删除obj.fn</span><br><span class="hljs-comment">//注意点：obj 有可能为null，此时this指向window；call可能有返回值</span><br><br><span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> context = context || <span class="hljs-built_in">window</span>;<br>  <span class="hljs-comment">//this为指向调用call的函数</span><br>  context.fn = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-comment">//call可传参，通过arguments可获取</span><br>  <span class="hljs-keyword">var</span> args = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++)<br>  &#123;<br>    args.push(<span class="hljs-string">&#x27;arguments[&#x27;</span> + i + <span class="hljs-string">&#x27;]&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">var</span> res = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;context.fn(&#x27;</span> + args + <span class="hljs-string">&#x27;)&#x27;</span>);<br><br>  <span class="hljs-keyword">delete</span> context.fn;<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>apply</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">//与call实现类似</span><br><span class="hljs-built_in">Function</span>.prototype.myApply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> context = context || <span class="hljs-built_in">window</span>;<br>  context.fn = <span class="hljs-built_in">this</span>;<br><br>  <span class="hljs-keyword">var</span> res;<br>  <span class="hljs-keyword">if</span> (!arr) &#123;<br>    res = obj.fn();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">var</span> args = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++)<br>    &#123;<br>      args.push(<span class="hljs-string">&#x27;arr[&#x27;</span> + i + <span class="hljs-string">&#x27;]&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">var</span> res = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;context.fn(&#x27;</span> + args + <span class="hljs-string">&#x27;)&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">delete</span> context.fn;<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>bind</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-built_in">Function</span>.prototype.myBind (context) &#123;<br>  <span class="hljs-comment">//如果调用者不是函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">//调用bind的函数</span><br>  <span class="hljs-keyword">var</span> selt = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-comment">//获取参数（arguments[0]为绑定的this）</span><br>  <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);<br><br>  <span class="hljs-comment">//bind返回的函数可以 new</span><br>  <span class="hljs-keyword">var</span> FNOP = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><br>  <span class="hljs-keyword">var</span> fBound = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">//获取new bind返回的函数时所传的参数</span><br>    <span class="hljs-keyword">var</span> bindArgs = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);<br>    <span class="hljs-comment">//修改this</span><br>    <span class="hljs-keyword">return</span> self.apply(<span class="hljs-built_in">this</span> instance fNOP ? <span class="hljs-built_in">this</span> : context, args.concat(bindArgs));<br>  &#125;<br><br>  fBound.prototype = <span class="hljs-keyword">new</span> fNOP;<br>  <span class="hljs-keyword">return</span> fBound;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="class-实现"><a href="#class-实现" class="headerlink" title="class 实现"></a>class 实现</h3><h3 id="promise-实现"><a href="#promise-实现" class="headerlink" title="promise 实现"></a>promise 实现</h3><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><blockquote><p>柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">//简版</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> args = [].slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> totalArgs = args.concat([].slice.call(<span class="hljs-built_in">arguments</span>));<br>    <span class="hljs-keyword">return</span> fn.apply(totalArgs);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><blockquote><p>数组的扁平化，就是将一个嵌套多层的数组 array 转换成只有一层的数组</p></blockquote><ul><li><p>递归实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> res = [];<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(arr[i])) &#123;<br>      res.concat(flatten(arr[i]));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res.push(arr[i]);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>toString（如果数组的元素都是数字，可以考虑这种）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> arr.toString().split(<span class="hljs-string">&quot;,&quot;</span>).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> +item;<span class="hljs-comment">//将每个元素转回Number类型</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>reduce</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prev, next</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> prev.concat(<span class="hljs-built_in">Array</span>.isArray(next) ? flatten(next) : next);<br>  &#125;, [])<span class="hljs-comment">//设置初始值 []</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>扩展运算符（扩展运算符，用于取出参数对象的所有可遍历属性，拷贝到当前对象之中，一次只能扁平一层）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">while</span> (arr.some(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-built_in">Array</span>.isArray(item)) &#123;<br>    arr = [].concat(...arr);<br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>手写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS</title>
    <link href="/2021/11/20/css/"/>
    <url>/2021/11/20/css/</url>
    
    <content type="html"><![CDATA[<ul><li>css 盒模型</li><li>BFC</li><li>flex</li><li>清除浮动</li><li>水平垂直居中</li><li>圣杯布局</li><li>双飞翼布局</li><li>多行、多列自适应布局</li><li>文本超出省略号显示</li><li>实现 1px 边框？1px 线条？</li><li>伪类和伪元素区别？使用场景？</li></ul><h3 id="1-css-盒模型"><a href="#1-css-盒模型" class="headerlink" title="1.css 盒模型"></a>1.css 盒模型</h3><blockquote><p>包括 <strong>内容区域、内边距区域、边框区域和外边距区域</strong></p><p><strong>content + padding + border + margin</strong></p></blockquote><h4 id="W3C-盒模型（标准盒模型）"><a href="#W3C-盒模型（标准盒模型）" class="headerlink" title="W3C 盒模型（标准盒模型）"></a>W3C 盒模型（标准盒模型）</h4><p><img src="/assets/img/w3c_box.jpeg" alt="alt W3C 标准盒模型"></p><h4 id="IE-盒模型（怪异盒模型）"><a href="#IE-盒模型（怪异盒模型）" class="headerlink" title="IE 盒模型（怪异盒模型）"></a>IE 盒模型（怪异盒模型）</h4><p><img src="/assets/img/ie_box.jpeg" alt="alt W3C 标准盒模型"></p><h4 id="相关属性：box-sizing-content-box-border-box"><a href="#相关属性：box-sizing-content-box-border-box" class="headerlink" title="相关属性：box-sizing: content-box/border-box"></a>相关属性：box-sizing: content-box/border-box</h4><hr><h3 id="2-BFC"><a href="#2-BFC" class="headerlink" title="2.BFC"></a>2.BFC</h3><h4 id="什么是-BFC？"><a href="#什么是-BFC？" class="headerlink" title="什么是 BFC？"></a>什么是 BFC？</h4><blockquote><p>BFC 全称为 <strong><em>块级格式化上下文 (Block Formatting Context)</em></strong> 。BFC 是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位以及与其他元素的关系和相互作用，当涉及到可视化布局的时候，Block Formatting Context 提供了一个环境，HTML 元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成 BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。这里有点类似一个 BFC 就是一个独立的行政单位的意思。可以说 BFC 就是一个作用范围，把它理解成是一个独立的容器，并且这个容器里 box 的布局与这个容器外的 box 毫不相干。</p></blockquote><h4 id="触发-BFC-的条件"><a href="#触发-BFC-的条件" class="headerlink" title="触发 BFC 的条件"></a>触发 BFC 的条件</h4><ul><li>根元素或其他包含它的元素</li><li>浮动元素（float 不是 none）</li><li>绝对定位元素（position 为 absolute 或 fixed）</li><li>内联块（display: inline-block）</li><li>表格单元格（display: table-cell, HTML 表格单元格默认属性）</li><li>表格标题（display: table-caption, HTML 表格标题默认属性）</li><li>具有 overflow 且值不是 visible 的块元素</li><li>弹性盒（flex 或 inline-flex）</li><li>display: flow-root</li><li>column-span: all</li></ul><h4 id="BFC-的约束规则"><a href="#BFC-的约束规则" class="headerlink" title="BFC 的约束规则"></a>BFC 的约束规则</h4><ul><li>内部的盒子会在垂直方向上一个接一个排列</li><li>处于同一个 BFC 中的元素上下 margin 会重叠</li><li>每个元素的 margin 的左边，与容器的 border 的左边相接触</li><li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</li><li>计算 BFC 的高度时，考虑 BFC 所包含的所有元素，连浮动元素也参与计算（_经常利用该规则解决元素高度塌陷的问题_）</li></ul><h4 id="BFC-可以解决的问题"><a href="#BFC-可以解决的问题" class="headerlink" title="BFC 可以解决的问题"></a>BFC 可以解决的问题</h4><ul><li>垂直外边距重叠问题</li><li>去除浮动</li><li>自适应两列布局（float + overflow）</li></ul><hr><h3 id="3-flex-布局（弹性布局-详情可进入"><a href="#3-flex-布局（弹性布局-详情可进入" class="headerlink" title="3.flex 布局（弹性布局 详情可进入)"></a>3.flex 布局（弹性布局 <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">详情可进入</a>)</h3><blockquote><p>display: flex/inline-flex;</p></blockquote><h4 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h4><ul><li>flex-direction: row | row-reverse | column | column-reverse; 决定主轴方向</li><li>flex-wrap: nowrap | wrap | wrap-reverse; 定义如果一条轴线排不下，如何换行</li><li>flex-flow: flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap</li><li>justify-content: flex-start | flex-end | center | space-between | space-around 定义项目在主轴上的对齐方式</li><li>align-items: flex-start | flex-end | center | baseline | stretch 定义项目在交叉轴上如何对齐<blockquote><p>baseline: 项目的第一行文字的基线对齐。</p><p>stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。</p></blockquote></li><li>align-content: flex-start | flex-end | center | space-between | space-around | stretch 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</li></ul><h4 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h4><ul><li>order: 定义项目的排列顺序 数值越小，排列越靠前，默认为 0</li><li>flex-grow: 定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大</li><li>flex-shrink: 定义项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小</li><li>flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间。默认值是 auto，即项目原本的大小</li><li>flex： flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选</li></ul><h3 id="4-清除浮动"><a href="#4-清除浮动" class="headerlink" title="4.清除浮动"></a>4.清除浮动</h3><ul><li><p>添加空 div 元素 {clear: both; height :0; overflow: hidden;}</p><blockquote><p>原理：添加一个空 div，利用 css 的 clear: both 清除浮动，让父级能够自动获取高度</p><p>优点：简单、代码少、浏览器支持好、不容易出现怪问题</p><p>缺点：会添加无用的空 div</p></blockquote></li><li><p>给浮动元素父级设置高度</p><blockquote><p>原理：直接定义父级元素高度，解决父级高度无法获取高度的问题</p><p>优点：简单、代码少、容易掌握</p><p>缺点：只适合父级元素定高的情况，要给出精确的高度，如果高度与父级的不一样，会出现问题</p></blockquote></li><li><p>父级定义::after 伪元素 和 zoom</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.float_div</span>:after &#123;<br>  content: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">clear</span>: both;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br><span class="hljs-selector-class">.float_div</span> &#123;<br>  zoom: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>原理 IE8 以上和非 IE 才支持::after，zoom 可解决 ie6 7 浮动问题</p><p>优点：浏览器支持好、不容易出现怪问题</p><p>缺点：代码多</p></blockquote></li><li><p>父级设置 overflow: hidden;</p><blockquote><p>原理：必须定义 width 或者 zoom:1;同时不能定义 height；浏览器会自动检查浮动区域的高度</p><p>优点：简单、代码少、浏览器支持好</p><p>缺点：不能和 position 配合使用，因为超出的范围会被隐藏</p></blockquote></li><li><p>父级设置 overflow: auto;</p><blockquote><p>原理：必须定义 width 或者 zoom:1;同时不能定义 height；浏览器会自动检查浮动区域的高度</p><p>优点：简单、代码少、浏览器支持好</p><p>缺点：内部宽高超过父级时，会出现滚动条</p></blockquote></li><li><p>父级（包括父级同级元素）同时设置浮动</p><blockquote><p>原理：所有盒子一起浮动，就变成一个整体</p><p>缺点：会形成新的浮动问题（不推荐使用）</p></blockquote></li><li><p>父级设置成 display: table;</p><blockquote><p>不推荐使用</p></blockquote></li></ul><h3 id="5-水平垂直居中"><a href="#5-水平垂直居中" class="headerlink" title="5.水平垂直居中"></a>5.水平垂直居中</h3><ul><li><p>居中元素宽高固定时</p><ul><li>absolute + top 50%; left 50% + margin-left: -50%;margin-top: -50%</li><li>absolute + top bottom left right 0 + margin: auto</li><li>absolute + top left calc(50% - 居中元素的 1/2 宽高)</li></ul></li><li><p>居中元素宽高未知</p><ul><li>absolute + transform(-50%, -50%) （transform 属性可相对自身宽高进行偏移）</li><li>line-height（父元素定高且设置 line-height，text-align:center;居中元素设置为 inline-block，line-height:initial）</li><li>flex</li><li>css-table（父元素 display: table-cell,text-align:center,vertical-align: middle;居中元素 display: inline-block）</li></ul></li></ul><h3 id="6-圣杯布局（浮动实现）"><a href="#6-圣杯布局（浮动实现）" class="headerlink" title="6.圣杯布局（浮动实现）"></a>6.圣杯布局（浮动实现）</h3><blockquote><p>实现过程大致如下：</p><p>1.这三个 div 的 HTML 摆放的先后顺序是有讲究的，middle 这个显示在中间的 div，在 html 里是排在最前面的，然后是 left，最后是 right。</p><p>2.在 container 没有设置 padding，left 这个 div 和 right 这个 div 都没设置 margin 与相对定位 relative 之前，三个 div 都 float：left。这时候页面上显示的是 middle 独占一行，然后是 left 这个 div，然后是 right 这个 div</p><p>3.然后 left 这个 div 设置 margin-left：-100%。这样 left 就能从第二排蹦到第一排最左边并覆盖 middle 这个 div。</p><p>4.right 这个 div 设置 margin-left: -200px;这个值是它自己宽度的大小。然后 right 这个 div 也蹦到第一排最右边并覆盖 middle 这个 div。</p><p>5.这个时候 container 设置 padding，这个 padding 的大小是 left 与 right 这两个 div 分别的宽度，然后 left 与 right 这两个 div 分别再设置相对定位，移动自己宽度的距离，就正常显示了。</p><p>这种布局方式 ie7 都兼容，ie6 没有测试过。。。</p><p>如果想要这三个 div 中间有间隙，那么可以设置 container 的 padding 值与两个 div 的 left 和 right 值。比如上面例子想有 10px 的间隙，那就设置 left 这个 div 的 left 值为-210px，right 这个 div 的 right 值为-210px,然后设置 container 的 padding:0 210px。就能达到效果</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;middle green&quot;</span>&gt;</span>middle<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left red&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right yellow&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">210px</span>;<br>  <span class="hljs-selector-class">.left</span>,<br>  <span class="hljs-selector-class">.middle</span>,<br>  <span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">text-align</span>: left;<br>  &#125;<br>  <span class="hljs-selector-class">.left</span>,<br>  <span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">position</span>: relative;<br>  &#125;<br>  <span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">left</span>: -<span class="hljs-number">210px</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">right</span>: -<span class="hljs-number">210px</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.middle</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.red</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: red;<br>  &#125;<br>  <span class="hljs-selector-class">.yellow</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>  &#125;<br>  <span class="hljs-selector-class">.green</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: green;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-1-仿圣杯布局（绝对定位实现）"><a href="#6-1-仿圣杯布局（绝对定位实现）" class="headerlink" title="6.1 仿圣杯布局（绝对定位实现）"></a>6.1 仿圣杯布局（绝对定位实现）</h4><blockquote><p>这种方式实现的思路是：左右两边绝对定位，然后中间的 div 设置 left right，也能达到同样的效果。也不用在意中间的三个 div 的排版顺序</p><p>这种布局想要中间有间隙，只要 left right 的值分别大于左右两个 div 的宽度就行了</p><p>也兼容 ie7，ie6 没测试过</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container2&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left red&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;middle green&quot;</span>&gt;</span>middle<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right yellow&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container2</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-selector-class">.left</span>,<br>  <span class="hljs-selector-class">.middle</span>,<br>  <span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">text-align</span>: left;<br>  &#125;<br>  <span class="hljs-selector-class">.left</span>,<br>  <span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.middle</span> &#123;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">210px</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">210px</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.red</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: red;<br>  &#125;<br>  <span class="hljs-selector-class">.yellow</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>  &#125;<br>  <span class="hljs-selector-class">.green</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: green;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-双飞翼布局"><a href="#7-双飞翼布局" class="headerlink" title="7. 双飞翼布局"></a>7. 双飞翼布局</h3><blockquote><p>双飞翼布局和圣杯布局看起来都差不多，但是最大的不同就是：双飞翼布局中 middle 中间的这个 div 里面还有一个 div，主要通过这个 div 的 margin 值来达到布局的目的。然后 left 和 right 这两个 div 都不用再设置相对定位 relative。其它的都基本一样</p><p>这个布局的间隙就是设置 middle 这个 div 里面的 div 的 margin 左右的值大于两边 div 宽度就行了。</p><p>兼容 ie7，ie6 未测试过。</p><p>总结：圣杯布局的 HTML 中 div 的顺序都是自适应宽度的 div 排最前，然后是固定宽度的 div。然后只操作固定宽度的 div 的 margin 等值，然后装这三个 div 的盒子设置 padding 值，最后自适应宽度的 div 就只需设置 100%宽度和浮动就行了。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container3&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;middle&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;middle-in green&quot;</span>&gt;</span>left-in<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left red&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right yellow&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container3</span> &#123;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-selector-class">.left</span>,<br>  <span class="hljs-selector-class">.right</span>,<br>  <span class="hljs-selector-class">.middle</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">text-align</span>: left;<br>  &#125;<br>  <span class="hljs-selector-class">.left</span>,<br>  <span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.middle</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.middle-in</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">210px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br>  &#125;<br>  <span class="hljs-selector-class">.red</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: red;<br>  &#125;<br>  <span class="hljs-selector-class">.yellow</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>  &#125;<br>  <span class="hljs-selector-class">.green</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: green;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-多行、多列自适应布局"><a href="#8-多行、多列自适应布局" class="headerlink" title="8. 多行、多列自适应布局"></a>8. 多行、多列自适应布局</h3><h3 id="9-文本超出省略号显示"><a href="#9-文本超出省略号显示" class="headerlink" title="9. 文本超出省略号显示"></a>9. 文本超出省略号显示</h3><h4 id="单行文本"><a href="#单行文本" class="headerlink" title="单行文本"></a>单行文本</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.ellipsis</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">text-overflow</span>: ellipsis;<br>  <span class="hljs-attribute">white-space</span>: nowrap;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.ellipsis2</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">display</span>: -webkit-box;<br>  -webkit-line-clamp: <span class="hljs-number">2</span>; <span class="hljs-comment">/* 指定块容器中内容限制为指定行数 */</span><br>  -webkit-box-orient: vertical;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP相关</title>
    <link href="/2021/11/20/http/"/>
    <url>/2021/11/20/http/</url>
    
    <content type="html"><![CDATA[<h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><blockquote><ol><li>GET：发送一个请求获取服务器上的某一资源</li><li>POST：向 URL 指定的资源提交数据或附加新的数据</li><li>PUT：跟 POST 很像，也是向服务器提交数据。但是，他们之前有不同。PUT 指定了资源在服务器上的位置，而 POST 没有</li><li>HEAD：只请求页面的首部</li><li>DELETE：删除服务器上的某资源</li><li>OPTIONS：用于获取当前 URL 所支持的方法。如果请求成功，会有一个 Allow 的头包含类似”GET, POST”这样的信息</li><li>TRACE：用于激发一个远程的，应用层的请求消息回路</li><li>CONNECT：把请求连接转换成透明的 TCP/IP 通道</li></ol></blockquote><h3 id="HTTP-状态码及其含义"><a href="#HTTP-状态码及其含义" class="headerlink" title="HTTP 状态码及其含义"></a>HTTP 状态码及其含义</h3><ul><li>1XX：信息状态码<blockquote><ol><li>100 Continue 继续，一般在发送 post 请求时，已发送了 http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息</li></ol></blockquote></li><li>2XX：成功状态码<blockquote><ol><li>200 OK 正常返回信息</li><li>201 Created 请求成功并且服务器创建了新的资源</li><li>202 Accepted 服务器已接受请求，但尚未处理</li></ol></blockquote></li><li>3XX：重定向<blockquote><ol><li>301 Moved Permanently 请求的网页已永久移动到新位置。</li><li>302 Found 临时性重定向。</li><li>303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。</li><li>304 Not Modified 自从上次请求后，请求的网页未修改过。</li></ol></blockquote></li><li>4XX：客户端错误<blockquote><ol><li>400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li><li>401 Unauthorized 请求未授权。</li><li>403 Forbidden 禁止访问。</li><li>404 Not Found 找不到如何与 URI 相匹配的资源。</li></ol></blockquote></li><li>5XX：服务器端错误<blockquote><ol><li>500 Internal Server Error 最常见的服务器端错误。</li><li>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</li></ol></blockquote></li></ul><h3 id="HTTP-报文的组成部分"><a href="#HTTP-报文的组成部分" class="headerlink" title="HTTP 报文的组成部分"></a>HTTP 报文的组成部分</h3><blockquote><ol><li>请求报文</li></ol></blockquote><blockquote><ul><li>请求行（http 方法 + 页面地址 + http 协议 + 版本）</li><li>请求头（key + value）</li><li>空行（服务器通过空行来判断下一部分不再是请求头，而当做请求题来解析）</li><li>请求体（数据部分）</li></ul></blockquote><blockquote><ol start="2"><li>响应报文</li></ol></blockquote><blockquote><ul><li>状态行（http 协议 + 版本号 + 状态码 + 状态描述）</li><li>响应头</li><li>空行</li><li>响应体</li></ul></blockquote><h3 id="从输入-URL-到呈现页面过程"><a href="#从输入-URL-到呈现页面过程" class="headerlink" title="从输入 URL 到呈现页面过程"></a>从输入 URL 到呈现页面过程</h3>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
